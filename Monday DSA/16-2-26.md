## LRU Cache

```python
class Node:
    def __init__(self,key,val,prev=None,nextt=None):
        self.key=key
        self.val=val
        self.prev=prev
        self.next=nextt
class LruCache:
    def __init__(self, cacheCapacity):
        self.cache={} # key -> node ref 
        self.max=cacheCapacity
        self.head,self.tail=Node(0,0),Node(0,0)
        self.tail.next=self.head
        self.head.prev=self.tail
        
    def getValue(self, key: int) -> int:
        if key not in self.cache: return -1
        val=self.cache[key].val
        node=self.cache[key]
        node.prev.next=node.next
        node.next.prev=node.prev
        node.next=self.head
        node.prev=self.head.prev
        self.head.prev.next=node
        self.head.prev=node
        return val
        
    def putValue(self, key: int, val: int) -> None:
        if key in self.cache: 
            node=self.cache[key]
            node.prev.next=node.next
            node.next.prev=node.prev
            del self.cache[key]
        node=Node(key,val)
        node.prev=self.head.prev
        node.next=self.head
        self.head.prev.next=node
        self.head.prev=node
        self.cache[key]=node
        if len(self.cache)>self.max:
            lru=self.tail.next
            lru.prev.next=lru.next
            lru.next.prev=lru.prev
            del self.cache[lru.key]
```

## Find Mex with allowed +/- operation

```python
def find_max_mex(nums,a):
    from collections import Counter
    c=Counter(x%a for x in nums)
    mex=0
    while True:
        r=mex%a 
        if c[r]>0:
            c[r]-=1
            mex+=1
        else: break
    return mex
# we try every mex starting from 0. if mex%a has count > 0, number is already possible. if not, number not available in the list
```

## Aestroid Collision

```python
def resolveAsteroidCollisions(nums):
    res=[]
    n=len(nums)
    for i in range(n):
        if nums[i]>=0: res.append(nums[i])
        else:
            a=nums[i]*-1
            while res and res[-1]>0 and res[-1]<a: #stack top is >0 but <curr_num
                res.pop() #it is crushed by the curr_num which is greater
            if res and res[-1]==a: res.pop() #if equal, just remove stack top
            elif not res or res[-1]<a: res.append(-a) #if res empty or top is <num, just append curr_num
    return res
```

## Next Greater Element

```python
def findNextGreaterElements(nums):
    m=len(nums)
    nums.extend(nums)
    stack=[]
    n=len(nums)
    res=[0]*n
    #monotonic decreasing stack strict
    for i,num in enumerate(nums):
        while stack and nums[stack[-1]]<num:
            ind=stack.pop()
            res[ind]=num
        stack.append(i)
    while stack:
        i=stack.pop()
        res[i]=-1
    return res[:m]
```

## Queue using Stacks

```python
class QueueUsingStacks:
    def __init__(self):
        self.s1=[]
        self.s2=[]
    def pushElement(self, x):
        self.s1.append(x)
        
    def popElement(self):
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()
    def peekElement(self):
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2[-1]
    def isEmptyResult(self):
        return self.s2==[] and self.s1==[]
```

## Reverse words in a string

```python
def reverseWords(s: str) -> str:
    s=[l.strip() for l in s.split()]
    res=""
    for l in s[::-1]:
        if l: res+=(l+" ")
    return res.strip()
